#include<cstdint>

/*
190. 颠倒二进制位 https://leetcode.cn/problems/reverse-bits/
    颠倒给定的 32 位无符号整数的二进制位。
    提示：
        请注意，在某些语言（如 Java）中，没有无符号整数类型。
        在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，
        因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
        在 Java 中，编译器使用二进制补码记法来表示有符号整数。
        因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
    
    示例 1：
        输入：n = 00000010100101000001111010011100
        输出：964176192 (00111001011110000010100101000000)
        解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
            因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

    示例 2：
        输入：n = 11111111111111111111111111111101
        输出：3221225471 (10111111111111111111111111111111)
        解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
            因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
*/
uint32_t reverseBits(uint32_t n) {
    uint32_t res = 0;//保存结果
    //for循环一次取出n的二进制表示的每一位 取完右移一位，所以每次取最后一位即可
    for (int i = 0; i < 32 && n > 0; ++i) {
    //(n & 1) 取n二进制表示的最后一位 1的二进制表示为00000000000000000000000000000001
    //所以 n最后一位为1，(n & 1)就为1   n最后一位为0，(n & 1)就为0 
    //(31-i)表示倒序添加到翻转结果rev中，即n的最后一位添加到rev首位位置
    //相当于把00000000000000000000000000000001变成
    //10000000000000000000000000000000
    //|= 相当于不进位加法运算，0|1=1 , 0|0=0  就是把当前的取出的二进制位加到对应的rev中
        res |= (n & 1) << (31 - i);
        n >>= 1;
    }
    return res;
}